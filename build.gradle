
buildscript {
	repositories {
		maven {
			url "https://plugins.gradle.org/m2/"
		}
		// maven {
		// 	url "${System.env.ARTIFACTORY_URL}/repo"
		// }
	}
	dependencies {
		classpath "org._10ne.gradle:rest-gradle-plugin:0.4.2"
		classpath "org.jfrog.buildinfo:build-info-extractor-gradle:3.1.1"
	}
}

plugins {
    id "de.undercouch.download" version "3.2.0"
}

apply plugin: "base"
apply plugin: 'maven-publish'
apply plugin: "org.tenne.rest"
apply plugin: "com.jfrog.artifactory"

import com.pega.pw2017.ResultHandler
import com.pega.pw2017.FileFinder
import de.undercouch.gradle.tasks.download.Download

ant.importBuild 'prpcServiceUtils/scripts/utils/prpcServiceUtilsWrapper.xml'

ext {
	resultHandler = new ResultHandler(project)
}

group = 'dmorg'
version = applicationVersion + '_' + System.env.BUILD_NUMBER

def archiveName = "${applicationName}_${applicationVersion}"
def archiveNameWithExt = "${archiveName}.zip"
def exportFolder = FileFinder.insureDirectoryExists("${buildDir}/export")
def importFolder = FileFinder.insureDirectoryExists("${buildDir}/import")
def artifactLocation = System.env.ARTIFACTORY_URL + '/ims_dev_repo/' + group + '/' + project.applicationName + '/' + version + '/' + project.applicationName + '-' + project.applicationVersion + '_' + System.env.BUILD_NUMBER + '.zip'
//replace https with http since the download location does not require sign in
artifactLocation = artifactLocation.replaceAll(/^https\:/, 'http:')

ant.properties['export.applicationName'] = project.applicationName
ant.properties['export.applicationVersion'] = project.applicationVersion
ant.properties['export.archiveName'] = archiveNameWithExt
ant.properties['service.responseartifacts.dir'] = exportFolder
ant.properties['export.async']='false'
ant.properties['import.async']='false'
ant.properties['import.archive.path']= importFolder

publishing {
    publications {
        main(MavenPublication) {
            artifact file(FileFinder.findFile(exportFolder, archiveNameWithExt))
        }
    }
}

artifactory {
    contextUrl = System.env.ARTIFACTORY_URL
    publish {
        repository {
            repoKey = 'ims_dev_repo'
            username = artifactoryUser
            password = artifactoryPassword
            mavenCompatible = true
        }
        defaults {
            publications ('main')
        }
        publishBuildInfo = true
        publishArtifacts = true
    }
}

task fetchFromArtifactory(type: Download) {
	group 'Pega'
	description 'Fetch application archive from artifactory'

	println 'Downloading artifact from : ' + artifactLocation
    src artifactLocation
    username artifactoryUser
    password artifactoryPassword
    dest importFolder

}


task createRestorePoint(type: org._10ne.gradle.rest.RestTask) {
	group 'Pega'
	description 'Create restore point.'

	def targetURL = findProperty("targetURL")
	uri = "${targetURL}/PRRestService/SystemManagement/V2/RestorePoint"

	username = pegaUsername
	password = pegaUsername

	httpMethod = 'post'
	contentType = groovyx.net.http.ContentType.JSON
	responseHandler = { response ->
		def restorepointName = response.pxRestorePoints[0].pxRestorePointName

		resultHandler.putResult("restorepoint.name", restorepointName)
		println "Success: ${response.toString()}"
	}

	doFirst {
		// Validate project properties
		if (!project.hasProperty('targetURL')) {
			throw new InvalidUserDataException("Must supply '-PtargetURL'")
		}
	}
}

task revertToLastRestorePoint(type: org._10ne.gradle.rest.RestTask) {
	group 'Pega'
	description 'Create restore point.'

	def restorepointName = resultHandler.getResult("restorepoint.name")
	def targetURL = findProperty("targetURL")
	uri = "${targetURL}/PRRestService/SystemManagement/V2/rollback/${restorepointName}?action=SystemRollback"

	username = pegaUsername
	password = pegaPassword

	httpMethod = 'post'
	contentType = groovyx.net.http.ContentType.JSON

	responseHandler = { response ->
		println "Success: ${response.toString()}"
	}

	doFirst {
		// Validate project properties
		if (!project.hasProperty('targetURL')) {
			throw new InvalidUserDataException("Must supply '-PtargetURL'")
		}
	}
}

task getConflicts(type: org._10ne.gradle.rest.RestTask) {
	group 'Pega'
	description 'Check for branch conflict.'

	def branch = findProperty("branch")
	def targetURL = findProperty("targetURL")

	httpMethod = 'get'
	uri = "${targetURL}/api/v1/branches/${branch}/conflicts"

	username = pegaUsername
	password = pegaPassword

	contentType = groovyx.net.http.ContentType.JSON
	responseHandler = { response ->
		if (response.conflictsCount as int == 0) {
			println "No conflicts!"
		} else {
			println "Conflicts found: ${response.conflicts}"
			throw new BuildCancelledException("Found '${response.conflictsCount}' conflicts.")
		}
	}

	doFirst {
		// Validate project properties
		if (!project.hasProperty("branch") || !project.hasProperty('targetURL')) {
			throw new InvalidUserDataException("Must supply '-Pbranch' and '-PtargetURL'")
		}
	}
}

task merge(type: org._10ne.gradle.rest.RestTask) {
	group 'Pega'
	description 'Merge a branch.'

	def branch = findProperty("branch")
	def targetURL = findProperty("targetURL")

	httpMethod = 'get'
	uri = "${targetURL}/api/v1/branches/${branch}/merge"

	username = pegaUsername
	password = pegaPassword

	contentType = groovyx.net.http.ContentType.JSON
	responseHandler = { response ->
		resultHandler.putResult("merge.id", response.ID)
		println "Merge Response Queue ID : $response.ID"
	}

	doFirst {
		// Validate project properties
		if (!project.hasProperty("branch") || !project.hasProperty('targetURL')) {
			throw new InvalidUserDataException("Must supply '-Pbranch' and '-PtargetURL'")
		}
	}
}

task getMergeStatus(type: org._10ne.gradle.rest.RestTask) {
	group 'Pega'
	description 'Check merge status.'

	def mergeId = resultHandler.getResult("merge.id") ?: ""
	def targetURL = findProperty("targetURL")

	httpMethod = 'get'
	uri = "${targetURL}/api/v1/merges/${java.net.URLEncoder.encode(mergeId, "UTF-8")}"

	username = pegaUsername
	password = pegaPassword

	contentType = groovyx.net.http.ContentType.JSON
	responseHandler = { response ->
		resultHandler.putResult("merge.status", response.statusMessage)
		if(response.statusMessage.equals("Processing")){
			//Merge still Processing
			throw new BuildCancelledException("The merge status for '${mergeId}' is still '${response.statusMessage}'.")
		} else if (response.statusMessage.equals("Success")){
			//Merge Succesful
			println "Merge is complete for '${mergeId}', Status Message: '${response.statusMessage}'"
		} else {
			//Possible Conflicts?
			println "Error while performing merge for: '${mergeId}'"
			println "Errors: '${response.errors}'"

			throw new BuildCancelledException("Error while merging for '${mergeId}' '${response.statusMessage}' '${response.errors}'")
		}
	}

	doFirst {
		// Validate project properties
		if (!project.hasProperty('targetURL')) {
			throw new InvalidUserDataException("Must supply '-PtargetURL'")
		}
	}
}

task executePegaUnitTests(type: org._10ne.gradle.rest.RestTask) {
	group 'Pega'
	description 'Execute PegaUnit tests'

	def targetURL = findProperty("targetURL")
	def accessGroup = findProperty('accessGroup')
	def testSuite = findProperty('testSuite')
	//println buildDir
	//uri = "${targetURL}/PRRestService/PegaUnit/Rule-Test-Unit-Case/pzExecuteTests?LocationOfResults=" + java.net.URLEncoder.encode(file(buildDir).toString(), "UTF-8")
	uri = "${targetURL}/PRRestService/PegaUnit/Rule-Test-Unit-Case/pzExecuteTests"
	if (accessGroup != null) {
		println uri
		uri = uri + "?AccessGroup=" + java.net.URLEncoder.encode(accessGroup, "UTF-8")
	}
	if (testSuite) {
		uri = uri + "&TestSuite=" + java.net.URLEncoder.encode(testSuite, "UTF-8")
	}
	
	username = pegaUsername
	password = pegaPassword

	httpMethod = 'post'
	contentType = groovyx.net.http.ContentType.XML

	responseHandler = { response ->
		println "Successful test execution: ${response.toString()}"
	}

	doFirst {
		// Validate project properties
		if (!project.hasProperty('targetURL')) {
			throw new InvalidUserDataException("Must supply '-PtargetURL'")
		}
	}
}
